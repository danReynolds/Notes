# Mechanism: Address Translation
The CPU was developed using **Limited Direct Execution (LDE)**, the idea being that the program runs directly on the hardware, however, when exceptions (system calls, interrupts, exceptions), occur, control switches to the kernel.

In virtualizing memory, the approach is similar, attain both efficiency and control while providing the desired virtualization.

Additionally, the Virtual Memory needs to be **flexible,** programs should be able to user their address spaces in whatever way they like, making the system easier to program.

## How to Efficiently and Flexibly Virtualize Memory
The general technique to achieve this, which is considered an addition to the approach of limited direct execution is **hardware-based address translation.**

With address translation, the hardware transforms each memory address such as an instruction fetch, load or store, changing the **virtual** addresses provided to **physical** addresses where the desired info is actually located.

Therefore on each memory reference, an address translation is performed by the hardware to redirect application memory references to their actual locations in memory.

The hardware does the actual low-level translating of the memory, but the OS must be set up to make sure the correct translation takes place and **manage memory**.

The OS must keep track of which locations are free and which are in use, intervening to maintain control over how memory is used.

The goal of all of this is create the illusion that the program has its own private memory, where its own code and data reside.

Behind that illusion is the truth that many programs are actually sharing memory at the same time, as the CPUs switch between running one program and the next.

Through virtualization, the OS turns the ugly machine reality into something that is useful, powerful and easy to use.

## Assumptions
This is the baby approach where we make assumptions for teaching purposes that are not true in the real-world:

1. Assume that the user's address space must be placed *contiguously* in physical memory.
2. The size of the address space is not too big, it is *less than the size of physical memory*.
3. Each address space is **exactly** the *same size.*

## Interposition
Powerful technique in virtualizing memory where the hardware will interpose in each memory access and translate each virtual address issued by the processs to a physical address where the desired info is actually stored.

This powerful technique achieves transparency, without changing the client's interface.

Imagine that there is a process whose address space starts with program code at 0KB and ends at 2KB, heap begins at 2KB and ends at 4KB, free begins at 4KB and ends at 14KB and stack begins at 14KB and ends at 16KB.

Now take a code sequence that loads a value from memory, increments it by three, and then stores it back.

		void func()
			int x;
			...
			x = x + 3;

The compiler turns this line of code into assembly and when the instructions run, from the perspective of the process, the memory accesses that would take place would be:

* Fetch instruction at address 128 (for mv)
* Execute this instruction (load from address 15KB in the stack)
* Fetch instruction at address 132 (add 3)
* Execute this instruction (no memory reference required)
* Fetch the instruction at 136 (sw)
* Execute this instruction (store x+3 at address in 15KB of stack)

From the program's perspective, its **address space** starts at 0 and grows to a maximum of 16KB and all memory references it generates should be within those bounds.

However, to virtualize memory, the OS wants to place the process somewhere else in physical memory, not necessarily at address 0.

How cant his process be relocated in a way that is transparent to the process?

In reality the process is 16KB long starting at 32KB or wherever else the OS decides to put it.

## Dynamic Hardware-Based Relocation
To better understand hardware-based address translation, we'll go through some techniques. The **base and bounds** technique, also called **dynamic relocation**, required two hardware registers within each CPU.

The first is the **base** register, and the other is the **bounds** or **limit** register.

This base and bounds pair allows us to place the address space anywhere in physical memory while ensuring that the process can only access its own address space.

In this setup, **each program** is **written** and **compiled** as if it is loaded at address 0.

However, when the program starts running, the OS decides where in physical memory it should be loaded and sets the **base register** to that value.

In the example above, the OS decided to load the process at address 32KB instead of 0.

Now when any memory reference is generated by the process, it is **translated** by the processor:

		physical address = virtual address + base

Since the process was built assuming it started at address 0, if it is loaded at 32KB and wants to access what it thought would be address 4, just take the base, 32KB, and add the virtual address, 4 to get 32KB + 4, the correct physical address.

Each memory reference in the process is virtual, and the hardware adds the contents of the base register to this virtual address to get the right physical address every time.

So an instruction in the process to load from 15KB will be translated to 47KB (Physical address) = 32KB (base register)  + 15KB (referenced virtual address).

Because this relocation of the address space happens at runtime, and because we can move address spaces even **after the process has started running** (then just update the base register), the technique is called **dynamic relocation**. Memory references are dynamically changed on the fly by the hardware as the program executes.

While the **base** register is used to transform virtual addresses into physical addresses, the **bounds** register, or **limit** register ensures that addresses are within the confines of the process address space.

The **base and bounds / dynamic relocation** provides a simple and efficient virtualization of memory.

The bounds/limit register would be be set to 16KB in this program, the difference between where it thinks it starts, at 0, and ends, at 16KB for the start of the stack.

If the process generates an address that is greater than the bounds, or one that is negative (so as described here this is done before adding the base, it is purely a length check), the CPU will raise an exception and the process will be terminated.

The bounds register ensures that all memory addresses generated by the process are within the legal bounds of the process' address space.

The base and bounds registers are hardware structures kept on the chip, one pair per CPU. Sometimes the part of the processor that helps with address translation is called the **Memory Management Unit (MMU)**. As we develop more sophisticated memory management techniques, the MMU will become more complicated.

Note, the bound / limit register can be defined in one of two ways:

1. It can hold the **size** of the address space, and have the hardware check the virtual address generated against the size, since the process starts at address 0. If it is above the size or negative, it is out of bounds.
2. The bounds register can also hold the physical address of the end of the address space, so when a virtual memory reference is checked, it first adds the base and then compares with the bound register.

Both methods are equivalent, but for now we will use approach 1 and have the bounds register hold the length/size of the address space.

## Example Translations
Imagine a process with an address space of 4KB, very small, that has been loaded into physical address 16KB.

* Virtual address (VA) 0 is translated to physical address (PA) 16KB by the base reg.
* VA 1KB = PA 17KB
* VA 3KB = PA 19KB
* VA 4.4KB is not translated! It is out of bounds based on the length, 4KB, held in the bounds register.

## Data Structures
The OS must track which parts of free memory are not in use, so as to be able to allocate memory to processes. Many different data structures can be used, the simplest is a **free list**, which is a list of the ranges of the physical memory not in use.

## OS Issues
There are a number of new OS issues that arise when using base and bounds to implement a simple virtual memory.

There are three critical junctures where the OS must take action to implement this base and bounds approach to memory virtualization:

1. When the process is created, the OS must find space for its address space in memory. Given our baby assumptions that the the virtual memory of the process is less than the physical memory, and that each process is the same size, this is easy, it can just view physical memory as an array of slots and track whether each one is free or in use. When a new process is created, the OS will have to search a data structure, the **free list**, to find room for the new address space and then mark it used.

2. The OS must take action when a process is terminated, reclaiming all of its memory for the use in other processes of the OS. Upon termination of a process, the OS puts its memory back on the free list and cleans up any data structures as needed.

3. The OS must take action when context switches occur. There is only one base and bounds register on each CPU, and their values differ for each running process. We assume they all want the same-sized address space, for now, so we don't need to change the bound register, but the base register is different, 4KB for one process and 8KB for another, or 20KB, etc. The OS must therefore **save** and **restore** the **base** and **bounds** pair when it switches between processes.


When the OS stops running a process, it must save the values of the base and bounds registers to memory in some per-process structure such as a **process control block (PCB)**. When the OS resumes running the process, or it runs for the first time, it must set the values of the base and bound registers.

Note that it is possible for the OS to move an address space from one location in memory to another when a process is not running.

To move the address space like this, the OS deschedules the process, then copies the address space from the current location in physical memory to the new one, and updates the saved **base register** in the **process structure** to point to the new starting location in physical memory.

The process can then be restarted, oblivious to the fact it has been moved.

Access to the base and bounds registers is necessarily a **privileged** operation.

If a process running in user mode attempts to do so, the CPU will raise an exception and the OS will terminate the process.

## Summary
In addition to limited direct execution, we have extended this technique to include the virtual memory mechanism of **address translation.**

Hardware support is key to the efficiency of this technique, which performs the translation quickly for **each access**. **Each** virtual memory reference is **translated individually.** 

All of this is performed transparently to the process that has been relocated.

Base and bounds translation is efficient, only a little hardware logic is required. And it offers protection, the OS and hardware combine to ensure no process can generate memory references outside of its own address space.

This system of dynamic relocation does have **inefficiencies:**

1. A process with an address space of 16KB is using physical memory from 32KB, for example, to 48KB even though its stack and heap are relatively small. The space between the two, the free space, is wasted. This waste is usually called **internal fragmentation**, as the space inside the allocated unit is not all used (fragmented).

2. Although there might be enough physical memory for more processes, we are currently restricted to placing an address space in a fixed-sized slot and fragmentation can arise.

A more sophisticated machinery is needed to try and better utilize physical memory and avoid fragmentation. The first attempt will be a generalization of base and bounds called **segmentation.**

